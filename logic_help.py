import sys
import os

def clear_screen():
    # Очистка экрана для Windows и Linux/Mac
    os.system('cls' if os.name == 'nt' else 'clear')

def wait_key():
    input("\nНажмите Enter, чтобы вернуться в меню...")

# ==============================================================================
#                               КОНТЕНТ СПРАВКИ
# ==============================================================================

TOPIC_SYNTAX = """
================================================================================
                        1. СИНТАКСИС И ОПЕРАЦИИ
================================================================================

Программа работает с формулами классического исчисления высказываний.

[Основные символы]
  Переменные:  Любые латинские буквы или слова (A, B, P, Q, var1).
  ->           Импликация (следование). Основная связка.
  ~            Отрицание (НЕ).
  ( )          Скобки для группировки.

[Приоритет операций]
  1. Отрицание (~)      - Самый высокий
  2. Импликация (->)    - Самый низкий (право-ассоциативная)

[Примеры]
  Корректно:   A -> B
  Корректно:   ~A -> (B -> ~C)
  Корректно:   (P -> Q) -> ((Q -> R) -> (P -> R))
"""

TOPIC_TRANSFORM = """
================================================================================
                  2. ПРЕОБРАЗОВАНИЕ ФОРМУЛ (И / ИЛИ)
================================================================================

Ядро программы (аксиоматика Гильберта) работает только с импликацией (->) 
и отрицанием (~). Другие связки должны быть преобразованы пользователем.

1. Дизъюнкция (ИЛИ, OR, v)
---------------------------
Формула:    A v B
Эквивалент: ~A -> B
Логика:     "A или B" равносильно "Если A ложно, то B должно быть истинно".

2. Конъюнкция (И, AND, &)
---------------------------
Формула:    A & B
Эквивалент: ~(A -> ~B)
Логика:     "И A, и B" равносильно "Неверно, что из A следует ложность B".

[Пример ввода]
Вместо "A & B -> A" введите:  ~(A -> ~B) -> A
"""

TOPIC_AXIOMS = """
================================================================================
                       3. АКСИОМЫ
================================================================================

Доказательство строится на трех схемах аксиом.

A1
-----------------------
Формула:  A -> (B -> A)
Смысл:    Истинное утверждение A следует из любого условия B.

A2
-----------------------------------
Формула:  (A -> (B -> C)) -> ((A -> B) -> (A -> C))
Смысл:    Позволяет "распределить" условие A на посылку и следствие.

A3
---------------------------------------------------------------
Формула:  (~B -> ~A) -> ((~B -> A) -> B)
Смысл:    Если предположение (~B) ведет к противоречию (из него следует 
          как ~A, так и A), то предположение ложно, а утверждение B истинно.
"""

TOPIC_RULES = """
================================================================================
                       4. ПРАВИЛО ВЫВОДА (MODUS PONENS)
================================================================================

В системе используется единственное правило прямого вывода.

Modus Ponens (MP)
-----------------

Математическая запись:
    A,  A -> B
    ----------
        B

Алгоритм:
1. Если в доказательстве (или среди гипотез) есть формула X.
2. И есть формула вида (X -> Y).
3. То мы имеем право добавить в доказательство формулу Y.

В выводе программы это обозначается как:
[MP из i и j], где i и j — номера строк, содержащих A и A->B.
"""

TOPIC_OUTPUT_FORMAT = """
================================================================================
                     5. ФОРМАТ ВЫВОДА (КАК ЧИТАТЬ)
================================================================================

Программа использует стиль Фитча (Fitch notation) для отображения структуры
доказательства. Это позволяет видеть вложенные гипотезы.

[Визуальные маркеры]
  |   (Вертикальная черта) - Указывает на уровень вложенности (контекст).
                             Пока черта идет, гипотеза выше остается в силе.
  |_  (Уголок)             - Обозначает ВВЕДЕНИЕ новой гипотезы.

[Пример разбора]

0. A              [|_ Гипотеза]         <-- (1)
1. ~B             [|  |_ Гипотеза]      <-- (2)
...
5. ~A             [|  |  MP ...]
...
8. B              [|  |  Вывод]         <-- (3)
9. ~B -> B        [|  Дедукция]         <-- (4)
10. A -> (~B->B)  [Дедукция]            <-- (5)

(1) Мы предположили A. Открылся первый уровень контекста.
(2) Внутри контекста A мы предположили ~B. Открылся второй уровень.
(3) Внутри второго уровня мы доказали B.
(4) Мы закрыли гипотезу ~B. Количество черт уменьшилось.
    Результат превратился в импликацию (~B -> B).
(5) Мы закрыли гипотезу A. Черт больше нет. Финальный результат.

[Индексы MP]
Запись [MP из 5 и 7] означает, что текущая строка получена применением
Modus Ponens к строкам с номерами 5 и 7.
"""

TOPIC_DEDUCTION = """
================================================================================
                        6. ТЕОРЕМА О ДЕДУКЦИИ
================================================================================

Формулировка:
Если из множества гипотез Г и формулы A выводится формула B (Г, A |- B),
то из Г выводится импликация A -> B (Г |- A -> B).

[Как это работает в программе]
Вместо того, чтобы строить A -> B через аксиомы, программа:
1. Временно добавляет A в список известных фактов ("Гипотеза").
2. Пытается доказать B обычными методами.
3. Если B доказано, она "сворачивает" этот блок в одну строку A -> B.
"""

TOPIC_CONTRADICTION = """
================================================================================
                  7. ДОКАЗАТЕЛЬСТВО ОТ ПРОТИВНОГО
================================================================================

Стратегия: Чтобы доказать цель G, мы предполагаем ~G
и ищем противоречие.

[Интуитивное объяснение]
Представьте, что мы хотим доказать, что на улице идет дождь (G).
1. Мы предполагаем обратное: "Дождя нет" (~G).
2. Из этого предположения мы логически выводим: "Асфальт сухой" (~F).
3. Но мы смотрим в окно и видим Факт: "Асфальт мокрый" (F).
4. У нас противоречие: если верить предположению, асфальт должен быть сухим,
   но на самом деле он мокрый.
5. Значит, предположение неверно. Значит, дождь идет.

[Формальная логика (Как это делает программа)]
В системе аксиом это реализуется через Аксиому A3:
   (~G -> ~F) -> ((~G -> F) -> G)

Программа должна предоставить Аксиоме A3 два "доказательства" (две посылки),
чтобы получить G:

1. ПОСЫЛКА №1: "Из предположения следует ложь" (~G -> ~F)
   Программа временно добавляет ~G в гипотезы и пытается вывести отрицание
   какого-нибудь известного факта.
   Если получилось, мы сворачиваем это в импликацию: ~G -> ~F.

2. ПОСЫЛКА №2: "Из предположения следует истина" (~G -> F)
   В логике, если F — истина, то F следует из чего угодно (Аксиома A1).
   Поэтому программа берет факт F и превращает его в импликацию:
   F -> (~G -> F).
   Так как F у нас есть, мы получаем: ~G -> F.

3. ФИНАЛ: Применение A3
   У нас есть:
     (a) ~G -> ~F  (Следствие нашего предположения)
     (b) ~G -> F   (Безусловная истина факта)
   
   Аксиома A3 говорит: "Если из ~G следует и ~F, и F, значит ~G ложно, а G истинно".
   Программа применяет Modus Ponens дважды и получает чистую формулу G.
"""

TOPIC_EXFALSO = """
================================================================================
               8. ПРИНЦИП ВЗРЫВА
================================================================================

В классической логике: "Из лжи следует всё что угодно".
Если в вашем доказательстве одновременно доказаны A и ~A, вы можете
мгновенно доказать любую целевую формулу B.

[Алгоритм доказательства]
Пусть у нас есть A и ~A. Цель: B.

1. Берем ~A.
   Применяем A1: ~A -> (~B -> ~A).
   MP: Получаем (~B -> ~A).

2. Берем A.
   Применяем A1: A -> (~B -> A).
   MP: Получаем (~B -> A).

3. Применяем A3 (в виде (~B -> ~A) -> ((~B -> A) -> B)).
   У нас есть обе посылки (из шага 1 и 2).
   Применяем MP дважды.
   Результат: B.

Программа автоматически ищет такие противоречия в списке гипотез, чтобы
мгновенно завершить доказательство.
"""

# ==============================================================================
#                               ЛОГИКА МЕНЮ
# ==============================================================================

MENU = {
    '1': ("Синтаксис и Операции", TOPIC_SYNTAX),
    '2': ("Преобразование формул (И/ИЛИ)", TOPIC_TRANSFORM),
    '3': ("Аксиомы (A1-A3)", TOPIC_AXIOMS),
    '4': ("Правило вывода (Modus Ponens)", TOPIC_RULES),
    '5': ("Формат вывода (Как читать)", TOPIC_OUTPUT_FORMAT),
    '6': ("Теорема о Дедукции (Логика)", TOPIC_DEDUCTION),
    '7': ("Доказательство от противного", TOPIC_CONTRADICTION),
    '8': ("Принцип взрыва", TOPIC_EXFALSO)
}

def print_menu():
    clear_screen()
    print("╔══════════════════════════════════════════════════════════════╗")
    print("║             СПРАВОЧНАЯ СИСТЕМА ПО МАТ. ЛОГИКЕ                ║")
    print("╚══════════════════════════════════════════════════════════════╝")
    print("\nВыберите раздел для изучения:")
    keys = sorted(MENU.keys(), key=int)
    for key in keys:
        print(f"  [{key}] {MENU[key][0]}")
    print("\n  [q] Выход в главное меню")

def run_help():
    while True:
        print_menu()
        choice = input("\nВаш выбор > ").strip().lower()
        
        if choice == 'q':
            print("Выход из справки...")
            break
        
        if choice in MENU:
            clear_screen()
            print(MENU[choice][1]) # Вывод текста
            wait_key()
        else:
            print("Неверный выбор.")

if __name__ == "__main__":
    run_help()